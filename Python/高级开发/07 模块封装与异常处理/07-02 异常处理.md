# 1. 什么是异常

## 1.1 错误

在运行或编写一个程序时常会遇到[错误异常](https://www.iplaypy.com/jichu/exception.html)，这时 python 会给你一个错误提示类名，告诉出现了什么样的问题（Python是面向对象语言，所以程序抛出的异常也是类）。能很好的理解这些错误提示类名所代表的意思，可以帮助你在最快的时间内找到问题所在，从而解决程序上的问题是非常有帮助的。

## 1.2  Python中的异常

在先前的一些章节里你已经执行了一些代码，你一定遇到了程序“崩溃”或因未解决的错误而终止的情况。你会看到“跟踪记录（traceback）”消息以及随后解释器向你提供的信息，包括错误的名称、原因和发生错误的行号。不管你是通过 Python 解释器执行还是标准的脚本执行，所有的错误都符合相似的格式，这提供了一个一致的错误接口。所有错误，无论是语意上的还是逻辑上的，都是由于和 Python 解释器不相容导致的，其后果就是引发异常。

我们来看几个异常的例子。

### 1.2.1 NameError

> 尝试访问一个未申明的变量

```python
>>> foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
```

NameError表示我们访问了一个没有初始化的变量。在Python解释器的符号表没有找到那个另人讨厌的变量，我们将在后面的两章讨论名称空间，现在大家可以认为它们是连接名字和对象的“地址簿”就可以了。任何可访问的变量必须在名称空间里列出，访问变量需要由解释器进行搜索，如果请求的名字没有在任何名称空间里找到，那么将会生成一个NameError异常。

### 1.2.2 ZeroDivisionError

> 除数为零

```python
>>> 1/0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```



我们边的例子使用的是整型，但事实上，任何数值被零除都会导致一个ZeroDivisionError异常。

### 1.2.3 SyntaxError

> Python解释器语法错误

```python
>>> for
  File "<stdin>", line 1
    for
      ^
SyntaxError: invalid syntax
```



SyntaxError异常是唯一不是在运行时发生的异常。它代表Python代码中有一个不正确的结构，在它改正之前程序无法执行。这些错误一般都是在编译时发生，Python解释器无法把你的脚本转化为Python字节代码。当然这也可能是你导入一个有缺陷的模块的时候。

### 1.2.4 IndexError

> 请求的索引超出序列范围

```python
>>> l[0]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

IndexError在你尝试使用一个超出范围的值索引序列时引发。

### 1.2.5 KeyError

> 请求一个不存在的字典关键字

```python
>>> d = {'host':'127.0.0.1', 'port':80}
>>> d['server']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'server
```

映射对象，例如字典，是依靠关键字（key）访问数据值的。如果使用错误的或是不存在的键请求字典就会引发一个KeyError异常。

### 1.2.6 IOError

> 输入/输出错误

```python
>>> f = open('test.txt')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: 'test.txt'
```

类似尝试打开一个不存在的磁盘文件一类的操作会引发一个操作系统输入/输出（I/O）错误。任何类型的I/O错误都会引发IOError异常。

### 1.2.7 AttributeError

> 尝试访问未知的对象属性

```python
>>> e = Example()
>>> e.bar = 'span'
>>> e.bar
'span'
>>> e.foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Example' object has no attribute 'foo'
```

在我们的例子中，我们在myInst.bar储存了一个值，也就是实例mylnst的bar属性。属性被定义后，我们可以使用熟悉的点/属性操作符访问它，但如果是没有定义属性，例如我们访问foo属性，将导致一个AttributeError异常。

# 2.  检测和处理异常

异常可以通过try语句来检测。任何在try语句块里的代码都会被监测，检查有无异常发生。

try语句有两种主要形式：try-except和try-finally。这两个语句是互斥的，也就是说你只能使用其中的一种。一个try语句可以对应一个或多个except子句，但只能对应一个finally子句，或是一个try-except-finally复合语句。

你可以使用try-except语句检测和处理异常。你也可以添加一个可选的else子句处理没有探测到异常的执行的代码。而try-finally只允许检测异常并做一些必要的清除工作（无论发生错误与否），没有任何异常处理设施。正如你想像的，复合语句两者都可以做到。

## 2.1  try-except语句

try-except语句（以及其更复杂的形式）定义了进行异常监控的一段代码，并且提供了处理异常的机制。

最常见的try-except语句语法如下所示。它由try块和except块（try_suite和except_suite）组成，也可以有一个可选的错误原因。

```python
try:
    try_suite	# 监控这里的代码
except Exception as e:
    except_suite	# 异常处理代码

```



我们用一个例子说明这一切是如何工作的。我们将使用上边的IOError例子，把我们的代码封装在try-except里，让代码更健壮：

```python
try:
    number = input('请输入一个数字')
    number = int(number)
except Exception as e:
    print(e)

```

如你所见，我们的代码运行时似乎没有遇到任何错误。事实上我们在尝试转化一个数据类型时仍然发生了错误。有什么区别么？我们加入了探测和错误错误的代码。当引发异常时，我们告诉解释器让它打印出一条诊断信息。程序继续执行，而不像以前的例子那样被“轰出来”——异常处理小小地显了下身手。那么在代码方面发生了什么呢？

在程序运行时，解释器尝试执行try块里的所有代码，如果代码块完成后没有异常发生，执行流就会忽略except语句继续执行。而当except语句所指定的异常发生后，我们保存了错误的原因，控制流立即跳转到对应的处理器（try子句的剩余语句将被忽略），本例中我们显示出一个包含错误原因的错误信息。

在我们上边的例子中，我们只捕获 ValueError 异常。任何其他异常不会被我们指定的处理器捕获。举例说，如果你要捕获一个特定的异常,你必须加入一个特定的异常处理器。

try语句块中异常发生点后的剩余语句永远不会到达（所以也永远不会执行）。一旦一个异常被引发，就必须决定控制流下一步到达的位置。剩余代码将被忽略，解释器将搜索处理器，一旦找到，就开始执行处理器中的代码。

如果没有找到合适的处理器，那么异常就向上移交给调用者去处理，这意味着堆栈框架立即回到之前的那个。如果在上层调用者也没找到对应处理器，该异常会继续被向上移交，直到找到合适处理器。如果到达最顶层仍然没有找到对应处理器，那么就认为这个异常是未处理的，Python解释器会显示出跟踪记录，然后退出。

## 2.2 异常的传递性

我们的目标是“安全地”调用float()函数，或是使用一个“安全的方式”忽略掉错误，因为它们与我们转换数值类型的目标没有任何联系，而且这些错误也没有严重到要让解释器终止执行。为了实现我们的目的，这里我们创建了一个“封装”函数，在try-except的协助下创建我们预想的环境，我们把他叫做safe_float()。在第一次改进中我们搜索并忽略ValueError,因为这是最常发生的。而TypeError并不常见，我们一般不会把非字符串数据传递给float()。

```python
def str_2_float(str_):
    try:
        return float(str_)
    except Exception as e:
        print(e)

```

我们采取的第一步只是“止血”。在上面的例子中，我们把错误“吞了下去”。换句话说，错误会被探测到，而我们在except从句里只是打印的错误信息，不进行任何处理，忽略这个错误。

这个解决方法有一个明显的不足，它在出现错误的时候没有明确地返回任何信息。虽然返回了None（当函数没有显式地返回一个值时，例如没有执行到 return object 语句函数就结束了，它就返回 None ,我们并没有得到任何关于出错信息的提示。我们至少应该显式地返回 None ,来使代码更容易理解：

```python
def str_2_float(str_):
    try:
        return float(str_)
    except Exception as e:
        print(e)
        # 执行错误 也应该返回信息
        return None


```

注意我们刚才做的修改，我们只是添加了一个局部变量。在有设计良好的应用程序接口（ApplicationProgrammer Interface, API）时，返回值可以更灵活。你可以在文档中这样写，如果传递给safe_float()合适的参数，它将返回一个浮点型；如果出现错误，将返回一个字符串说明输入数据有什么问题。我们按照这个方案再修改一次代码，如下所示：

```
def str_2_float(str_):
    try:
        return float(str_)
    except ValueError:
        return '不能将一个 Nan 转化为浮点数'

        return None


```

这里我们只是把None替换为一个错误字符串。下面我们试试这个函数看看它表现如何：

```python
>>> def str_2_float(str_):
...     try:
...         return float(str_)
...     except ValueError:
...         return '不能将一个 Nan 转化为浮点数'
...
>>> str_2_float('s')
'不能将一个 Nan 转化为浮点数'

```



我们有了一个好的开始——现在我们已经可以探测到非法的字符串输入了，可如果传递的是一个非法的对象，还是会“受伤”：

```python
>>> def str_2_float(str_):
...     try:
...         return float(str_)
...     except ValueError:
...         return '不能将一个 Nan 转化为浮点数'

>>> str_2_float({'a':'Dict'})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in str_2_float
TypeError: float() argument must be a string or a number, not 'dict'

```

我们暂时只是指出这个缺点，在进一步改进程序之前，首先来看看try-except的其他灵活的语法，特别是except语句，它有好几种变化形式。

## 2.3 带有多个 except 的 try 语句

在本章的前边，我们已经介绍了except的基本语法：

```python
except Exception[, reason]:
    suite_for_exception_Exception

```

这种格式的except语句指定检测名为Exception的异常。你可以把多个except语句连接在一起，处理一个try块中可能发生的多种异常，如下所示：

```python
except Exception1[, reason1]:
    suite_for_exception_Exception
except Exception2[, reason2]:
    suite_for_exception_Exception


```

同样，首先尝试执行try子句，如果没有错误，忽略所有的except从句继续执行。如果发生异常，解释器将在这一串处理器（except子句）中查找匹配的异常如果找到对应的处理器，执行流将跳转到这里。

我们的safe_float()函数已经可以检测到指定的异常了。更聪明的代码能够处理好每一种异常。这就需要多个except语句，每个except语句对应一种异常类型。Python支持把except语句串连使用我们将分别为每个异常类型分别创建对应的错误信息，用户可以得到更详细的关于错误的信息：

```python
def str_2_float(str_):
    try:
        return float(str_)
    except ValueError:
        return '不能将一个 Nan 转化为浮点数'
    except TypeError:
        return '类型错误，请传入正确的内容'

```

使用错误的参数调用这个函数，我们得到下面的输出结果：

```python
>>> def str_2_float(str_):
...     try:
...         return float(str_)
...     except ValueError:
...         return '不能将一个 Nan 转化为浮点数'
...     except TypeError:
...         return '类型错误，请传入正确的内容'
...
>>> str_2_float({'a':'dict'})
'类型错误，请传入正确的内容'
>>> str_2_float('a')
'不能将一个 Nan 转化为浮点数'

```

## 2.4  处理多个异常的except语句

我们还可以在一个except子句里处理多个异常。except语句在处理多个异常时要求异常被放在一个元组里：

```python
except (Exception1, Exception2)[,reason]:    
	suite_for_exception_Exception

```

上边的语法展示了如何处理同时处理两个异常。事实上except语句可以处理任意多个异常，前提只是它们被放入一个元组里，如下所示：

```python
except (Exce[, Exce[,...]])[,reason]:
    suite_for_exception_Exception

```



如果由于其他原因，也许是内存规定或是设计方面的因素，要求safe_float()函数中的所有异常必须使用同样的代码处理，那么我们可以这样满足需求：

```
def str_2_float(str_):
    try:
        return float(str_)
    except (ValueError, TypeError):
        return '参数必须是一个数字或者是一个字符串数字'

```

现在，错误的输入会返回相同的字符串

## 2.5  捕获所有异常

使用前一节的代码，我们可以捕获任意数目的指定异常，然后处理它们。如果我们想要捕获所有的异常呢？当然可以!自版本1.5后，异常成为类，实现这个功能的代码有了很大的改进。也因为这点（异常成为类），我们现在有一个异常继承结构可以遵循。

如果查询异常继承的树结构，我们会发现Exception是在最顶层的，所以我们的代码可能看起来会是这样：

```python
try:
    pass
except Exception as e:
    pass

```

我们没有指定任何要捕获的异常——这不会给我们任何关于可能发生的错误的信息。另外它会捕获所有异常，你可能会忽略掉重要的错误，正常情况下这些错误应该让调用者知道并做一定处理。最后，我们没有机会保存异常发生的原因。当然，你可以通过sys.exc_info()获得它，但这样你就不得不去导入sys模块，然后执行函数——这样的操作本来是可以避免的，尤其当我们需要立即告诉用户为什么发生异常的时候。在Python的未来版本中很可能不再支持空except子句（参见“核心风格”）。

很明显，错误无法避免，try-except的作用是提供一个可以提示错误或处理错误的机制，而不是一个错误过滤器。上边这样的结构会忽略许多错误，这样的用法是缺乏工程实践的表现，我们不赞同这样做。

底线：避免把大片的代码装入try-except中然后使用pass忽略掉错误。你可以捕获特定的异常并忽略它们，或是捕获所有异常并采取特定的动作。不要捕获所有异常，然后忽略掉它们。

## 2.6 finally子句

finally 子句是无论异常是否发生，是否捕捉都会执行的一段代码。你可以将 finally 仅仅配合 try 一起使用，也可以和 try-except （else也是可选的）一起使用。独立的 try-finally 将会在下一章介绍，我们稍后再来研究。

从Python 2.5开始，你可以用finally子句（再一次）与try-except或try-except-else—起使用。之所以说是“再一次”是因为无论你相信与否，这并不是一个新的特性。回顾Python初期，这个特性早已存在，但是在Python 0.9.6（1992 4月）中被移除。那时，这样可以简化字节码的生成，并方便解析，另外van Rossum认为一个标准化的try-except（-else）-finally无论如何不会太流行。然而，十年时间改变了一切！

下面是try-except-else-finally语法的示例：

```python
try:
    A
except Exception as e:
    B
finally:
    C

```

finally都是可选的。A、B、C是程序（代码块）。程序会按预期的顺序执行。（注意：可能的顺序是AD[正常]或AD[异常]）。无论异常发生在Α、Β和/或C都将执行finally块。旧式写法依然有效，所以没有向后兼容的问题。

## 2.7 else子句

我们已经看过else语句段配合其他的Python语句，比如条件和循环。至于try-except语句段，它的功能和你所见过的其他else没有太多的不同：在try范围中没有异常被检测到时，执行else子句。

在else范围中的任何代码运行前，try范围中的所有代码必须完全成功（也就是，结束前没有引发异常）。下面是用Python伪代码写的简短例子。

```
try:
    pass  # 尝试做
except Exception as e:
    pass  # 报错
else:
    pass  # except没有执行，就执行else
finally:
    pass  # 最终做

```

在前面的例子中，我们导入了一个外部的模块然后测试是否有错误。用一个日志文件来确定这个第三方模块是有无缺陷。根据运行时是否引发异常，我们将在日志中写入不同的消息。

## 2.8 完整格式  

> try-except-else-finally

我们综合了这一章目前我们所见过的所有不同的可以处理异常的语法样式：

```
try:
    pass  # 尝试做
except ValueError as e:
    pass  # 捕获一个错误
except (TypeError, SyntaxError) as e:
    pass  # 捕获多个错误
except Exception as e:
    pass  # 捕获其他错误
else:
    pass  # 没有捕捉到错误
finally:
    pass  # 最终都会执行

```

回顾上面，finally子句和try-except或try-except-else联合使用。这一节最重要的是无论你选择什么语法，你至少要有一个except子句，而else和finally都是可选的。

# 总结

1. 只处理你知道的异常，避免捕获所有异常然后吞掉它们。
2. 抛出的异常应该说明原因，有时候你知道异常类型也猜不出所以然。
3. 避免在`except`语句块中干一些没意义的事情，捕获异常也是需要成本的。
4. 不要使用异常来控制流程，那样你的程序会无比难懂和难维护。
5. 如果有需要，切记使用`finally`来释放资源。
6. 如果有需要，请不要忘记在处理异常后做清理工作或者回滚操作。